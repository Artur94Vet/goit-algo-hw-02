# Висновки щодо порівняння алгоритмів сортування

## Опис експерименту

Було порівняно три алгоритми сортування:

- **Merge Sort** — класичний алгоритм "розділяй і володарюй";
- **Insertion Sort** — простий алгоритм вставками (ефективний лише для дуже малих масивів);
- **Timsort** — вбудований в Python алгоритм, що поєднує переваги Merge Sort та Insertion Sort.

Час виконання вимірювався модулем `timeit` для різних обсягів вхідних даних.

---

## Емпіричні результати (приклад)

| Розмір | MergeSort (с) | InsertionSort (с) | Timsort (с) |
|--------|----------------|--------------------|--------------|
| 100    | 0.0003         | 0.0014             | 0.0001       |
| 500    | 0.0021         | 0.0260             | 0.0003       |
| 1000   | 0.0046         | 0.0900             | 0.0007       |
| 5000   | 0.0273         | 2.1013             | 0.0033       |

> (*Цифри умовні — взято з запуску на ПК. Фактично можуть дещо відрізнятись.*)

---

## Аналіз продуктивності

- **Insertion Sort** має квадратичну складність `O(n²)`, що чітко видно при зростанні обсягу даних — він стає непридатним для масивів > 500 елементів.
- **Merge Sort** демонструє стабільну логарифмічну продуктивність `O(n log n)`, але все одно повільніший за Timsort.
- **Timsort** показує найкращу ефективність на практиці завдяки комбінуванню:
  - сортування вставками — на малих підмасивах;
  - злиття — на великих ділянках.

---

## Висновок

- **Timsort** — найефективніший і стабільний варіант у реальних сценаріях.
- Саме тому в Python **не рекомендується реалізовувати сортування вручну**, а слід використовувати вбудовану функцію `sorted()` або метод `.sort()`.
- Поєднання Insertion Sort та Merge Sort у одному гібридному алгоритмі забезпечує оптимальну швидкодію на **будь-якому розмірі масиву**.

---

## Необов'язкове завдання — обʼєднання k відсортованих списків

Реалізовано функцію `merge_k_lists`, яка ефективно обʼєднує k відсортованих списків за допомогою модуля `heapq.merge()`.  
Це дозволяє зберігати загальну складність на рівні `O(n log k)`, що оптимально для великих потоків даних (наприклад, при роботі з логами або великими файлами).

**Результат прикладу:**
```python
[[1, 4, 5], [1, 3, 4], [2, 6]] → [1, 1, 2, 3, 4, 4, 5, 6]
