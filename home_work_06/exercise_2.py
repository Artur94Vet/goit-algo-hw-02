# Опис завдання
'''
Завдання 2

Напишіть програму, яка використовує алгоритми DFS і BFS для знаходження шляхів у графі, який було розроблено у першому завданні.

Далі порівняйте результати виконання обох алгоритмів для цього графа, висвітлить різницю в отриманих шляхах. Поясніть, чому шляхи для алгоритмів саме такі.
'''
# Виконання завдання

import networkx as nx
import matplotlib.pyplot as plt

# --- Побудова графа (частина Київського метро) ---
G = nx.Graph()

# Станції (фрагмент червоної лінії)
stations = [
    "Академмістечко", "Житомирська", "Святошин", "Нивки",
    "Берестейська", "Шулявська", "Політехнічний інститут", "Вокзальна",
    "Університет", "Театральна", "Хрещатик", "Арсенальна"
]

# Додавання ребер між станціями
edges = list(zip(stations, stations[1:]))
G.add_edges_from(edges)

# Пересадки
G.add_edge("Хрещатик", "Майдан Незалежності")  # до синьої лінії
G.add_edge("Театральна", "Золоті ворота")     # до зеленої лінії

# --- DFS (рекурсивно) ---
def dfs(graph, start, visited=None, path=None, parent=None):
    if visited is None:
        visited = set()
        path = []
    visited.add(start)
    if parent:
        path.append((parent, start))
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited, path, start)
    return path

# --- BFS (через чергу) ---
def bfs(graph, start):
    visited = set([start])
    queue = [start]
    path = []
    while queue:
        current = queue.pop(0)
        for neighbor in graph[current]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
                path.append((current, neighbor))
    return path

# --- Виконання пошуку ---
start_node = "Академмістечко"
dfs_result = dfs(G, start_node)
bfs_result = bfs(G, start_node)

# --- Вивід результатів ---
print("=== DFS (обхід у глибину) ===")
for edge in dfs_result:
    print(f"{edge[0]} → {edge[1]}")

print("\n=== BFS (обхід у ширину) ===")
for edge in bfs_result:
    print(f"{edge[0]} → {edge[1]}")

# --- Візуалізація графа ---
plt.figure(figsize=(12, 8))
pos = nx.spring_layout(G, seed=42)
nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=1500, edge_color='gray', font_size=10)
plt.title("Фрагмент Київського метро (для DFS і BFS)", fontsize=14)
plt.show()

'''
DFS заглиблюється максимально вглиб графа перед тим, як повертатись і досліджувати інші варіанти.
Алгоритм іде по одній гілці до кінця, лише потім повертається до інших відгалужень (якщо вони є).

Висновок:

DFS «довіряє» першому знайденому шляху, незалежно від того, наскільки він ефективний або короткий.
Не гарантує найкоротший шлях у графі.
----------------------------------------------------------
BFS вивчає всіх сусідів вузла перш ніж іти глибше, тобто досліджує граф рівень за рівнем.
Завжди знаходить найкоротший шлях у графі (за кількістю переходів), якщо існує.

Висновок:

BFS підходить краще для знаходження найкоротших маршрутів у транспортній мережі.
BFS додає у маршрут відгалуження раніше, ніж DFS (наприклад, пересадки — «Золоті ворота», «Майдан Незалежності» — з’являються раніше).

-----------------------------------------------------------
DFS не зупиняється, поки не дійде до кінця ланцюга, навіть якщо по дорозі є пересадка чи коротший шлях.
BFS працює з чергою, і тому одразу перевіряє всі можливості на кожному кроці, що й дозволяє «побачити» альтернативи раніше.
'''